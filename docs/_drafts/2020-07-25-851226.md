---
title: 
tags: 
---
youtubeのgraphqlのやつ

# CDNにキャッシュをのせたりできないのか？

現状できない。 アプリケーションサーバ上でキャッシュするしかない。 postのbodyではなくgetのquery
stringにクエリを詰めることも一応できる。 妄想としてはfastlyとかで（apollo
clientみたいに）parseして各フィールドのキャッシュをバラバラに保管できたらいいな。

persistent queryという仕組みをapolloが提供している。
サーバ側で予めqueryとそのハッシュ値を送ればクエリを叩いたのと同等の結果を返す。

cloud loggingとかだとRESTを前提にしてURLごとにlogをだすけど、
graphqlだとみんな/graphqlになるので、クエリごとにだすには適当な方法をみつけないといけない。

いろんなところで、RESTを前提にしたエコシステム内のプロダクトに対してはhackが必要になることが多い。

# クライアントキャッシュ

いま、あるリソースのステータスを参照しているコンポーネントが3つあったとする。
redux以前は、updateなコンポーネントそれぞれを更新する必要があった。 reduxによってsingle source of
truthさえ更新すれば、それを参照している3つのコンポーネントたちは自動的に更新される。
graphqlではmutationの戻り値としてステータスをとればクライアントライブラリがそれをsingle source of
truth的な場所にキャッシュして、 そのステータスを参照している3つのコンポーネントたちは自動的に更新される。

そのsignle source of truthは一階層で、uniqueなキーに対するバリューのセット。
uniqueなキーはuser1とかpost1とか、スキーマから自動的に生成できる。 reduxの場合は、このデータの正規化=フラット化が大変だった。

結果が頻繁に変更されるクエリは都度取得したいので「キャッシュをしない」という設定をする。
apolloではrefetchというのがあって、createFooというmutationを実行したらallFoosというクエリも再実行する
（リクエストを2つ投げる）ということができる。

1-10件目をクエリしてキャッシュした後に11-20件目をクエリしたとき、2つのクエリの間にサーバー側で変更があると
10件目と11件目が連続したものではなくなってしまう。そこのコントロールがつらい。

graphql以外からデータをとるとこのsingle source of truthを更新できない。
graphqlでデータをとるならgraphqlだけ（というか単一のクライアント）でやるべし。

また同様の理由からmutationしたら必ず状態が変化したリソースの情報を取得してキャッシュを更新すべし。

キャッシュをひたすら追加したらメモリあふれる？ みんなひたすら追加していて、気にしたことない。重い画像を無限スクロールとかだと考慮する必要があるかもね。

「これはキャッシュする、これはキャッシュしない」という選択的な設定はできるのか？

# グラフDBとの相性

Dgraphというのがある。（neo4jとどう違うんだろう。）

GraphqlみたいにするするクエリできるDB。RDBだとせっせとjoinしないといけない。
とくに入れ子構造になった複数のリソースをupdateするときに、構造化されたinputをそのままわたすと一括更新できたりするとhappy. ex-
Googlerが開発しているのでGCPに買収されたりするといいな。

リソース更新においては、更新する部分のみパッチ的に送るのと、更新後のデータ全体を送る方式がある。
基本的には差分のみ送る方が効率がいいけど、パッチ方式の問題は以下。
gqlgenではnullとの区別がつかないので、更新したくなくてnullを送っているのか、に更新したい（=全部削除したい）のかが区別できない。
（なんかgolangの性質による問題らしい。）

# mutationによってサーバ側で非同期な処理が走ったとき

clientMutationIdだけ取得して、それを元にpollingして更新を待つ。更新したらqueryする。

# Relay or Apollo?

relayはfacebookの持ちものという印象がつよく、広く一般のユーザーの期待に応える向きがよわい。
apolloの方がコミュニティがオープンで、現実の問題に対して拡張していく性質がつよい。
それに付随してフレームワークに対応しているのでエコシステムが幅広い。

graphql-anywhereのメリットはtypescriptで得られるメリットに重なる。 typescriptつかってればgraphql-
anywhereつかう追加的なメリットは特にないのでは。

codegenの方がなにかといい。

（あー。RESTに比べたときのgraphqlのメリットとしてあまり語られない気がするけど、レスポンスの型がわかるので型安全に扱えるってのがあるな。）

# エラーハンドリング

shopifyはUserErrorみたいなtypeを返すという実装をしている