---
title: 『Linuxのしくみ』読書メモ
tags: Linux
layout: post
---

[![［試して理解］Linuxのしくみ ～実験と図解で学ぶOSとハードウェアの基礎知識](https://m.media-
amazon.com/images/I/51CPvtuv+wL._SL160_.jpg)](https://www.amazon.co.jp/exec/obidos/ASIN/B079YJS1J1/hatena-
blog-22/)

[［試して理解］Linux のしくみ
～実験と図解で学ぶ OS とハードウェアの基礎知識](https://www.amazon.co.jp/exec/obidos/ASIN/B079YJS1J1/hatena-
blog-22/)

- 作者:[武内 覚](http://d.hatena.ne.jp/keyword/%C9%F0%C6%E2%20%B3%D0)
- 発売日: 2018/02/23
- メディア: Kindle 版

\*1

# ざっくり

CPU/メモリ/ストレージデバイスという構成とか、プロセススケジューリングとかスワッピングとかのトピック自体は知っているものも多かったけど、全体的に解像度がぐっと上がった気がしてよかった。

# 書いてあって知ったこと

- CPU のモード

  - CPU が処理を実行するときには、カーネルモードのいずれかの状態をとる
  - カーネルモードで実行される
  - たとえば以下のことはカーネルモードでしかできない
    - プロセス管理（含スケジューリング）
    - メモリ管理
    - ファイルシステム操作
    - デバイス操作

- システムコール

  - カーネルの処理が呼び出される
  - プロセスというのはユーザーモードの世界の処理の実行単位
  - システムコールが発行されると、
    - 新しいプロセスが立ち上がるのではない
    - そのプロセス内で「割り込み」というイベントが発生し、そのプロセスをカーネルの処理が実行される
  - C のアセンブラプログラム（及びオブジェクトプログラム）を生成することはない
    - アセンブルした libc.so というオブジェクトファイル（=標準ライブラリ）が配布されている
    - C のコンパイラが C のコードからオブジェクトプログラムを生成するとき、このオブジェクトプログラムに libc.so がリンクされる
    - このオブジェクトプログラムを実行するとき、プロセス管理やメモリ管理の必要が生じると必ず libc.so が実行され、libc.so の処理の中でシステムコールが発行される

- 各種コマンド

  - sar(system admin reporter)でいろいろ
  - free でメモリ
  - df(disk free)でディスク

- プロセスに nice(2)で優先度をつけると、プロセススケジューリングにおいてより多くの/少ない CPU 時間を割り当てることができる

- 仮想メモリと物理メモリがある

  - プロセス（カーネルの外、ユーザーの世界）から物理メモリに直接アクセスする方法はない
  - 仮想メモリと物理メモリの紐付けはページテーブルによって管理される
  - 仮想メモリと物理メモリを分離することのメリットは以下
    - 物理メモリ上で断片化せざるを得なかったとしても、仮想アドレス上では連続しているので大きなひとかたまりのデータをもつことが可能
    - 「各プロセスは、そのプロセスのページテーブルに記載された物理アドレスにしかアクセスできない」というルールを導入して、各プロセスが自身と関係ない物理メモリにアクセスすることを防げる
    - プログラムファイルはコード領域とデータ領域をメモリ上のどこにどれだけ確保するかという情報をもつ。物理メモリしかない場合、同じプログラムを複数のプロセスで実行すると、物理メモリ上のある領域を複数のプロセスがそれぞれ勝手につかおうとして困ってしまう。仮想メモリを挟むことによって、物理メモリとしては異なる領域を参照させ、干渉を避けることができる。
  - ページフォールトハンドラが物理メモリの割当（とページテーブルの書き換え）を行う。
  - ページテーブルをコンパクトにするため以下の仕組みがある。
    - 階層化して、対応する物理アドレスがない範囲については、その範囲に対応する下層のテーブルをそもそも作成しない
    - 仮想/物理メモリの対応関係が複数ページにわたって連続している場合、それらページをまとめて一単位（ヒュージページ）として対応関係を保持することでテーブルサイズを小さくする

- キャッシュメモリにも階層がある

- ティー状態にしといて、後でライトバック」とかの点で同型

- ハイパースレッドは以下の仕組み

  - CPU と（キャッシュ）メモリとの間でのデータ転送待ち時間の分 CPU をアイドルにしないために
  - 1 つの物理 CPU に、プロセス A のデータ転送待ちの間にプロセス B を処理させる
  - これを「論理 CPU X がプロセス A を、論理 CPU Y がプロセス B を引き受けている」状態として表現する

- デバイスはファイルとして表現され（`/dev/`配下など）、以下の 2 種類がある

  - キャバイス: 読み書きできるがランダムアクセスできない。端末やキーボードなど
  - ブロックデバイスなど

- ブロックデカーネルを介する）

  - dd とかで直接操作する
  - デファイルシステムを介して操作する

- ブロックデバイス層が以下の機能を提供する

  - 先読み: ある領域にアクセスするとつづけて後続の領域が必要になることがおおいので、言われなくてもついでに後続の領域を読み込んでおく
  - IO スケジューラ: IO の指示をちょっとためて、アクセスする領域についてソートしたり連続部分をマージしたりしてからまとめてアクセスする

- ブロックデバイスの IO パフォーマンスをよくするには

  - HDD でも SSD でも、シーケンシャルアクセスの場合は先読みでかなりパフォーマンスが上げられるので、なるべくシーケンシャルアクセスしよう
  - （どうせその領域全体が必要になるなら）細切れではなくなるべくまとめてアクセスしよう

# 書いてなくて知ったこと

- macOS(Mojave)には top, df はあるけど sar, free はない

- バイナリの置き場所

  - `/bin`: 非常時（シングルユーザーモード）でも利用できる必要があるコマンド
  - `/usr/bin`: yum）
  - `/usr/local/bin`: deb などのパッケージ管理システムによってシステムに管理されないコマンド（homebrew）
  - いずれも`sbin`はシステムから叩くコマンド

- 標準ライブラリは、コンパイラがデフォルトでリンクしてくれるから「標準」

- システムコールを呼び出す

  - コンパイルするときに、libc がリンクされる
  - Ruby のバイナリは libc へのリンクを含む（`ldd $(which ruby)`でわかる）
  - システムコールが必要な処理については libc が適宜実行される

# 次は

ここらへん読みたいな

[![ふつうのLinuxプログラミング 第2版　Linuxの仕組みから学べるgccプログラミングの王道](https://m.media-
amazon.com/images/I/41HbBZyeJ3L._SL160_.jpg)](https://www.amazon.co.jp/exec/obidos/ASIN/B075ST51Y5/hatena-
blog-22/)

[ふつうの Linux プログラミング 第 2 版
Linux の仕組みから学べる gcc プログラミングの王道](https://www.amazon.co.jp/exec/obidos/ASIN/B075ST51Y5/hatena-
blog-22/)

- 作者:[青木 峰郎](http://d.hatena.ne.jp/keyword/%C0%C4%CC%DA%20%CA%F6%CF%BA)
- 発売日: 2017/09/22
- メディア: Kindle 版

\*1:この要約には違法性はないと考える。<https://www.bengo4.com/c_1015/c_17/c_1263/b_341980/>
