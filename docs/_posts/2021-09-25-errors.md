---
title: 
tags: 
---

エラーについて自分なりの理解を整理する。

一般的な用語法にそぐわない部分があるかもしれないが、本記事の中での定義に即して記述する。

# 2つの"エラー"

エラーには2つある。

- 1.プログラミング言語が備えるエラーという機構
  - コールスタックをアンワインドする仕組み
- 2.アプリケーションにおけるエラーという概念
  - "想定を逸脱する事態"を指す緩やかな概念で、以下に分類される
    - 2-1. サービス利用者に起因するもの
      - この中にも「善意のユーザーが十分遭遇しうるので親切に対応したいもの」から「悪意あるユーザーでなければ生じないはずなので不親切な対応でよさそうなもの」まで幅がある
        - ex1. postのbodyが条件を満たなさいため本処理が実行できない
        - ex2. 認可の条件を満たさないのでデータを返却できない
    - 2-2. サービス提供者に起因するもの

1と2は本来別ものなので以下のようにずれる場合もある。

- 2に当たるけれど1を利用しない場合
  - 2-1 ex1 でバリデーションの結果得たメッセージをオブジェクトに詰めてユーザーに返すなど
- 2に当たらないけれど1を利用する場合
  - ストリームでEOFまで読んだときにエラーを投げる

つまり、**2の概念に当てはまるか否かに関わらず、1の機構がはまるところには1をつかうし、そうでなければつかわない**というだけの話。

以下では、ある関数において本筋として想定されていない事態が起きた場合に、それを関数の外側に伝えるにあたって1の機構をつかうか、つかわない(=戻り値で表現する)かを考える。

さてそもそも1の機構はどういう特徴をもっているのか。

- O
  - バケツリレーをせずにコールスタックを一気にアンワインドできる
    - = 戻り値で表現する必要はないのでシグネチャはシンプルなままで、例外クラスとメッセージという情報は伝達できる
- X
  - 投げたエラーをどこで拾うのかが見えにくく、可読性が落ちる
  - エラーを投げる場所で適当な後処理（transactionをrollbackするなど）がされないと不適切な状態になるリスクがある
  - エラーを拾わないとプロセスが不適切に終了するリスクがある

イメージとしては、「バトン(戻り値)を次の走者(呼び出し元)にちゃんとわたす」と「バトン(エラー)をぶん投げて(アンワインド)誰かが拾う(エラーハンドリング)」。

これを踏まえて、エラーという機構が適しているのは次の場面。
- a.どこでどう起きるのかが予見しにくい事態
- b.それが起きたら元の文脈を離れて=コールスタックを大きく遡って処理をすればいい事態

たとえば変数に想定外にnullが入ってしまいそのプロパティを参照できない場合。(2-2に該当する。)

動的型付け言語においてはこういう事態はいつどこで起こるかわからない。いつどこで起こるかわからないことに関して、
「この関数の内部でそれが起きた場合にはそのことを表現する戻り値をつくっておこう」とあらゆる関数のシグネチャに含めるのはナンセンスなのでaに該当する。

また、特に予期しない箇所においてこうした事態が想定外に発生してしまった場合は、その場に応じたきめ細かい対応はしようがないので、
エラーを投げて大元で拾い、webサービスなら500を返すなどすればよいので、bに該当する。

よって、例えばjsであればこの場合組み込みの`TypeError: Cannot read properties of null`というエラーが生じるが、このエラーをそのまま(関数内では拾わずに)関数の外側に対して投げるのが現実的な対応となる。

# assertion error / exception

エラーという機構には、2つの使われ方がある。assetion errorとexceptionである。

両者はプログラミング上の処理としては基本的に同一であり、その利用の目的/方法において区別される。

棒切れを杖としてつかうか、竿としてつかうかみたいなものである。

asssetion errorは出荷前の検査項目であり、コードに埋め込まれたテストである。それに対して、exceptionは出荷後の安全装置である。

例えば、以下のコードを考える。

```typescript
type Divider = (input: string) => number
const divider: Divider = input => {
  const [numerator, denominator] = input.split('/').map(Number)
  return _core(numerator, denominator)
}

type Core = (numerator: number, denominator: number) => number
const _core: Core = (numerator, denominator) => {
  const ret = numerator / denominator
  return ret
}
```

試しに色々な引数で呼んでみた。

```typescript
console.log(divider(''))               // NaN
console.log(divider('1'))              // NaN
console.log(divider('1/2'))            // 0.5
console.log(divider('1/2/3'))          // 0.5
console.log(divider('hoge'))           // NaN
console.log(divider('hoge/fuga'))      // NaN
console.log(divider('hoge/fuga/piyo')) // NaN
console.log(divider('0/2'))            // 0
console.log(divider('2/0'))            // Infinity
```

よくわからん値を与えても、よくわからん値を返してくるのでいまいちだ。

なにができて何ができないのかはっきりさせたい。以下の仕様でいこう。

- `/`で2つの部分に分割されなかったらエラーとする
- 分割された部分が両方数値として解釈できなかったらエラーとする
- 分母が0だったらエラーとする

これを踏まえると、コアの関数は以下のように定めてしまってよさそうだ。

- 事前条件: 2つの引数がいずれも数値、分母が0でない
- 事後条件: 戻り値は数値

これらをいったん契約としてassertを仕込む。

```typescript
type Core = (numerator: number, denominator: number) => number
const _core: Core = (numerator, denominator) => {
  assert.ok(!isNaN(numerator))
  assert.ok(!isNaN(denominator))
  assert.notStrictEqual(denominator, 0)
  const ret = numerator / denominator
  assert.ok(!isNaN(ret))
  return ret
}
```

当然このままだと事前条件の部分でばんばんAssertionErrorが発生する。

この事前条件を守るように呼び出し元を変更する。

```typescript
type Divider = (input: string) => number
const divider: Divider = input => {
  const strs = input.split('/')
  if (strs.length !== 2) throw new Error('Argument format is invalid.')
  const nums = strs.map(Number)
  if (nums.some(num => isNaN(num))) throw new Error('Argument must represent numbers.')
  const [numerator, denominator] = nums
  if (denominator === 0) throw new Error('Denominator cannot be zero.')
  return _core(numerator, denominator)
}
```

```typescript
console.log(divider(''))               // Argument format is invalid.
console.log(divider('1'))              // Argument format is invalid.
console.log(divider('1/2'))            // 0.5
console.log(divider('1/2/3'))          // Argument format is invalid.
console.log(divider('hoge'))           // Argument format is invalid.
console.log(divider('hoge/fuga'))      // Argument must represent numbers.
console.log(divider('hoge/fuga/piyo')) // Argument format is invalid.
console.log(divider('0/2'))            // 0
console.log(divider('2/0'))            // Denominator cannot be zero.
```

これで（少なくともテストしたパターンにおいては）常に契約が守られ、AssertionErrorが発生しない状態となった。

（ここで注意したいのは、`_core`の事前条件のassertは、`_core`のテストではなく、その呼び出し元のテストであるということ。）

assertionの役割は出荷前の検査項目たることであり、この時点で役割を果たし終えたので、このコードを本番で動かすときにはassertは無効化してよい。

他方で`divide`の`throw`は本番環境で起きうる事柄について安全装置として処理を定めたものなので、当然本番環境でも実行する必要がある。

